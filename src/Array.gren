module Array exposing
    ( Array
    , empty, singleton, initialize
    , isEmpty, length, get, set, pushFront, pushBack
    , foldl, foldr, map, indexedMap, filter, filterMap, prefix, postfix, reverse, intersperse
    , slice, dropLeft, dropRight, takeLeft, takeRight, popFirst, popLast
    , flatMap, flatten
    )

{-| This library provides an immutable version of native JavaScript arrays.

NOTE: All manipulations causes a copy of the entire Array, this can be slow.


# Arrays

@docs Array


# Creation

@docs empty, singleton, initialize


# Basics

@docs isEmpty, length, get, set, pushFront, pushBack


# Transformation

@docs foldl, foldr, map, indexedMap, filter, filterMap, concat, concatMap, prefix, postfix, reverse, intersperse


# Sub-arrays

@docs slice, dropLeft, dropRight, takeLeft, takeRight, popFirst, popLast

-}

import Basics exposing ((-), (==), Bool, Int)
import Gren.Kernel.Array
import Maybe exposing (Maybe(..))


{-| Representation of a javascript array.
-}
type Array a
    = Array a


{-| The empty array.
-}
empty : Array a
empty =
    []


{-| Return an array containing a single value.
-}
singleton : a -> Array a
singleton a =
    [ a ]


{-| Return the length of the array.
-}
length : Array a -> Int
length =
    Gren.Kernel.Array.length


{-| Check if an array is empty.
-}
isEmpty : Array a -> Bool
isEmpty array =
    length array == 0


{-| Initialize an array. `initalize n offset fn` creates an array of length `n`
with the element at index `i` initialized to the result of `(f (i + offset))`.

The offset parameter is there so one can avoid creating a closure for this use
case. This is an optimization that has proved useful in the `Array` module.

    initialize 3 5 identity == [ 5, 6, 7 ]

-}
initialize : Int -> Int -> (Int -> a) -> Array a
initialize =
    Gren.Kernel.Array.initialize


{-| Returns the element at the given index, or `Nothing` if index is out of bounds.
-}
get : Int -> Array a -> Maybe a
get =
    Gren.Kernel.Array.get


{-| Sets the element at the given index, or returns unmodified `Array` if index is out of bounds.
-}
set : Int -> a -> Array a -> Array a
set =
    Gren.Kernel.Array.set


{-| Reduce the array from the left.
-}
foldl : (a -> b -> b) -> b -> Array a -> b
foldl =
    Gren.Kernel.Array.foldl


{-| Reduce the array from the right.
-}
foldr : (a -> b -> b) -> b -> Array a -> b
foldr =
    Gren.Kernel.Array.foldr


{-| Apply a function on every element in an array.
-}
map : (a -> b) -> Array a -> Array b
map =
    Gren.Kernel.Array.map


{-| Apply a function on every element and its index in an array.

    indexedMap (,) [ 3, 3, 3 ] == [ ( 0, 3 ), ( 1, 3 ), ( 2, 3 ) ]

-}
indexedMap : (Int -> a -> b) -> Array a -> Array b
indexedMap =
    Gren.Kernel.Array.indexedMap


{-| Keep the values which passes the predicate

    filter (\n -> n < 3) [ 1, 2, 3, 4 ] == [ 1, 2 ]

-}
filter : (a -> Bool) -> Array a -> Array a
filter pred array =
    foldl
        (\v acc ->
            if pred v then
                pushFront v acc

            else
                acc
        )
        []
        array


{-| TODO
-}
filterMap : (a -> Maybe b) -> Array a -> Array b
filterMap mapper array =
    foldl
        (\v acc ->
            case mapper v of
                Just newValue ->
                    pushFront newValue acc

                Nothing ->
                    acc
        )
        []
        array


{-| TODO
-}
flatten : Array (Array a) -> Array a
flatten array =
    foldl postfix [] array


{-| TODO
-}
flatMap : (a -> Array b) -> Array a -> Array b
flatMap mapper array =
    foldl (\v acc -> prefix acc (mapper v)) [] array


{-| TODO
-}
pushFront : a -> Array a -> Array a
pushFront value array =
    prefix [ value ] array


{-| TODO
-}
pushBack : a -> Array a -> Array a
pushBack =
    Gren.Kernel.Array.push


{-| TODO
-}
prefix : Array a -> Array a -> Array a
prefix =
    Gren.Kernel.Array.append


{-| TODO
-}
postfix : Array a -> Array a -> Array a
postfix first second =
    prefix second first


{-| Get a sub section of an array: `(slice start end array)`.
The `start` is a zero-based index where we will start our slice.
The `end` is a zero-based index that indicates the end of the slice.
The slice extracts up to, but no including, the `end`.

Both `start` and `end` can be negative, indicating an offset from the end
of the array. Popping the last element of the array is therefore:
`slice 0 -1 arr`.

In the case of an impossible slice, the empty array is returned.

-}
slice : Int -> Int -> Array a -> Array a
slice =
    Gren.Kernel.Array.slice


{-| Remove `n` elements from the left side of the Array.

    dropLeft 1 [ 1, 2, 3 ] == [ 2, 3 ]

-}
dropLeft : Int -> Array a -> Array a
dropLeft n array =
    slice n (length array) array


{-| Remove `n` elements from the right side of the Array.

    dropRight 1 [ 1, 2, 3 ] == [ 1, 2 ]

-}
dropRight : Int -> Array a -> Array a
dropRight n array =
    slice 0 (length array - n) array


{-| Take `n` elements from the left side of the Array.

    takeLeft 1 [ 1, 2, 3 ] == [ 1 ]

-}
takeLeft : Int -> Array a -> Array a
takeLeft n array =
    slice 0 n array


{-| Take `n` elements from the right side of the Array.

    takeRight 1 [ 1, 2, 3 ] == [ 3 ]

-}
takeRight : Int -> Array a -> Array a
takeRight n array =
    let
        len =
            length array
    in
    slice (len - n) len array


{-| TODO
-}
popFirst : Array a -> Maybe ( a, Array a )
popFirst array =
    case get 0 array of
        Just value ->
            Just ( value, dropLeft 1 array )

        Nothing ->
            Nothing


{-| TODO
-}
popLast : Array a -> Maybe ( a, Array a )
popLast array =
    case get (length array - 1) array of
        Just value ->
            Just ( value, dropRight 1 array )

        Nothing ->
            Nothing


{-| TODO
-}
reverse : Array a -> Array a
reverse array =
    foldr pushBack empty array


{-| Places the given value between all members of the given list.
intersperse "on" ["turtles","turtles","turtles"] == ["turtles","on","turtles","on","turtles"]
-}
intersperse : a -> Array a -> Array a
intersperse sep xs =
    case popFirst xs of
        Nothing ->
            []

        Just ( hd, tl ) ->
            let
                step x rest =
                    pushFront sep (pushFront x rest)

                spersed =
                    foldr step [] tl
            in
            pushFront hd spersed
