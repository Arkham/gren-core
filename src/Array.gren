module Array
    exposing
        ( Array
        , empty
        , singleton
        , length
        , initialize
        , get
        , set
        , push
        , foldl
        , foldr
        , map
        , indexedMap
        , filter
        , filterMap
        , flatten
        , flatMap
        , prefix
        , postfix
        , slice
        , dropLeft
        , dropRight
        , takeLeft
        , takeRight
        )

{-| This library provides an immutable version of native JavaScript arrays.

NOTE: All manipulations causes a copy of the entire Array, this can be slow.

# Arrays
@docs Array

# Creation
@docs empty, singleton, initialize

# Basics
@docs length, get, set, push

# Transformation
@docs foldl, foldr, map, indexedMap, filter, filterMap, concat, concatMap, prefix, postfix

# Sub-arrays
@docs slice, dropLeft, dropRight, takeLeft, takeRight

-}


import Basics exposing (Int, Bool, (-))
import Maybe exposing (Maybe(..))
import Gren.Kernel.Array



{-| Representation of a javascript array.
-}
type Array a
    = Array a


{-| The empty array.
-}
empty : Array a
empty =
    []


{-| Return an array containing a single value.
-}
singleton : a -> Array a
singleton a =
    [ a ]


{-| Return the length of the array.
-}
length : Array a -> Int
length =
    Gren.Kernel.Array.length


{-| Initialize an array. `initalize n offset fn` creates an array of length `n`
with the element at index `i` initialized to the result of `(f (i + offset))`.

The offset parameter is there so one can avoid creating a closure for this use
case. This is an optimization that has proved useful in the `Array` module.

    initialize 3 5 identity == [5,6,7]
-}
initialize : Int -> Int -> (Int -> a) -> Array a
initialize =
    Gren.Kernel.Array.initialize


{-| Returns the element at the given index, or `Nothing` if index is out of bounds.
-}
get : Int -> Array a -> Maybe a
get =
    Gren.Kernel.Array.get


{-| Sets the element at the given index, or returns unmodified `Array` if index is out of bounds.
-}
set : Int -> a -> Array a -> Array a
set =
    Gren.Kernel.Array.set


{-| Push an element onto the array.
-}
push : a -> Array a -> Array a
push =
    Gren.Kernel.Array.push


{-| Reduce the array from the left.
-}
foldl : (a -> b -> b) -> b -> Array a -> b
foldl =
    Gren.Kernel.Array.foldl


{-| Reduce the array from the right.
-}
foldr : (a -> b -> b) -> b -> Array a -> b
foldr =
    Gren.Kernel.Array.foldr


{-| Apply a function on every element in an array.
-}
map : (a -> b) -> Array a -> Array b
map =
    Gren.Kernel.Array.map


{-| Apply a function on every element and its index in an array.

    indexedMap (,) [3, 3, 3] == [(0,3), (1,3), (2,3)]
-}
indexedMap : (Int -> a -> b) -> Array a -> Array b
indexedMap =
    Gren.Kernel.Array.indexedMap


{-| Keep the values which passes the predicate

    filter (\n -> n < 3) [1, 2, 3, 4] == [1, 2]
-}
filter : (a -> Bool) -> Array a -> Array a
filter pred array =
    foldl 
        (\v acc -> 
            if pred v then 
                push v acc 
            
            else 
                acc
        ) 
        [] 
        array


{-| TODO
-}
filterMap : (a -> Maybe b) -> Array a -> Array b
filterMap mapper array =
    foldl 
        (\v acc -> 
            case mapper v of
                Just newValue ->
                    push newValue acc 
                
                Nothing ->
                    acc
        ) 
        [] 
        array


{-| TODO
-}
flatten : Array (Array a) -> Array a
flatten array =
    foldl postfix [] array


{-| TODO
-}
flatMap : (a -> Array b) -> Array a -> Array b
flatMap mapper array =
    foldl (\v acc -> prefix acc (mapper v)) [] array


{-| TODO
-}
prefix : Array a -> Array a -> Array a
prefix =
    Gren.Kernel.Array.append


{-| TODO
-}
postfix : Array a -> Array a -> Array a
postfix first second =
    prefix second first


{-| Get a sub section of an array: `(slice start end array)`.
The `start` is a zero-based index where we will start our slice.
The `end` is a zero-based index that indicates the end of the slice.
The slice extracts up to, but no including, the `end`.

Both `start` and `end` can be negative, indicating an offset from the end
of the array. Popping the last element of the array is therefore:
`slice 0 -1 arr`.

In the case of an impossible slice, the empty array is returned.
-}
slice : Int -> Int -> Array a -> Array a
slice =
    Gren.Kernel.Array.slice


{-| Remove `n` elements from the left side of the Array.

    dropLeft 1 [1, 2, 3] == [2, 3]
-}
dropLeft : Int -> Array a -> Array a
dropLeft n array =
    slice n (length array) array


{-| Remove `n` elements from the right side of the Array.

    dropRight 1 [1, 2, 3] == [1, 2]
-}
dropRight : Int -> Array a -> Array a
dropRight n array =
    slice 0 (length array - n) array


{-| Take `n` elements from the left side of the Array.

    takeLeft 1 [1, 2, 3] == [1]
-}
takeLeft : Int -> Array a -> Array a
takeLeft n array =
    slice 0 n array


{-| Take `n` elements from the right side of the Array.

    takeRight 1 [1, 2, 3] == [3]
-}
takeRight : Int -> Array a -> Array a
takeRight n array =
    let
        len = 
            length array
    in
    slice (len - n) len array
