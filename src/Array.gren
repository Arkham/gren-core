module Array
    exposing
        ( Array
        , empty
        , singleton
        , length
        , initialize
        , get
        , set
        , push
        , foldl
        , foldr
        , map
        , indexedMap
        , slice
        )

{-| This library provides an immutable version of native JavaScript arrays.

NOTE: All manipulations causes a copy of the entire Array, this can be slow.

# Arrays
@docs Array

# Creation
@docs empty, singleton, initialize

# Basics
@docs length, get, set, push

# Transformation
@docs foldl, foldr, map, slice

-}


import Basics exposing (Int)
import Maybe exposing (Maybe)
import Gren.Kernel.Array



{-| Representation of a javascript array.
-}
type Array a
    = Array a


{-| The empty array.
-}
empty : Array a
empty =
    []


{-| Return an array containing a single value.
-}
singleton : a -> Array a
singleton a =
    [ a ]


{-| Return the length of the array.
-}
length : Array a -> Int
length =
    Gren.Kernel.Array.length


{-| Initialize an array. `initalize n offset fn` creates an array of length `n`
with the element at index `i` initialized to the result of `(f (i + offset))`.

The offset parameter is there so one can avoid creating a closure for this use
case. This is an optimization that has proved useful in the `Array` module.

    initialize 3 5 identity == [5,6,7]
-}
initialize : Int -> Int -> (Int -> a) -> Array a
initialize =
    Gren.Kernel.Array.initialize


{-| Returns the element at the given index, or `Nothing` if index is out of bounds.
-}
get : Int -> Array a -> Maybe a
get =
    Gren.Kernel.Array.get


{-| Sets the element at the given index, or returns unmodified `Array` if index is out of bounds.
-}
set : Int -> a -> Array a -> Array a
set =
    Gren.Kernel.Array.set


{-| Push an element onto the array.
-}
push : a -> Array a -> Array a
push =
    Gren.Kernel.Array.push


{-| Reduce the array from the left.
-}
foldl : (a -> b -> b) -> b -> Array a -> b
foldl =
    Gren.Kernel.Array.foldl


{-| Reduce the array from the right.
-}
foldr : (a -> b -> b) -> b -> Array a -> b
foldr =
    Gren.Kernel.Array.foldr


{-| Apply a function on every element in an array.
-}
map : (a -> b) -> Array a -> Array b
map =
    Gren.Kernel.Array.map


{-| Apply a function on every element and its index in an array.

    indexedMap (,) [3, 3, 3] == Array [(0,3), (1,3), (2,3)]
-}
indexedMap : (Int -> a -> b) -> Array a -> Array b
indexedMap =
    Gren.Kernel.Array.indexedMap


{-| Get a sub section of an array: `(slice start end array)`.
The `start` is a zero-based index where we will start our slice.
The `end` is a zero-based index that indicates the end of the slice.
The slice extracts up to, but no including, the `end`.

Both `start` and `end` can be negative, indicating an offset from the end
of the array. Popping the last element of the array is therefore:
`slice 0 -1 arr`.

In the case of an impossible slice, the empty array is returned.
-}
slice : Int -> Int -> Array a -> Array a
slice =
    Gren.Kernel.Array.slice
